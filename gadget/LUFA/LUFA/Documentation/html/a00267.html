<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LUFA (Formerly MyUSB) Library: Host Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Host Management<br/>
<small>
[<a class="el" href="a00276.html">USB - LUFA/Drivers/USB/USB.h</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ga8233ed35f4abbb180ec8304ce483d406">USB_HOST_DEVICEADDRESS</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ga97d683c3c4341eb303681e66058a8888">USB_HOST_TIMEOUT_MS</a>&nbsp;&nbsp;&nbsp;1000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ga4591576cd26d635aa5dfdf992ed99a3f">HOST_DEVICE_SETTLE_DELAY_MS</a>&nbsp;&nbsp;&nbsp;1500</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#gaa30175c751f951c44bf24fc901480652">USB_Host_States_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652af3f3f87924f879ce2395033b9affd999">HOST_STATE_WaitForDeviceRemoval</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652a8bb200e2f9e667c5ae530fb635b793ee">HOST_STATE_WaitForDevice</a> =  1, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652af95e1b584ddb58ca115bc7fbbc923ba0">HOST_STATE_Unattached</a> =  2, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652af6c9134a477d97b02f0ceaf457b03302">HOST_STATE_Powered</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652a3059481e2036f4f398302f373b024cb7">HOST_STATE_Powered_WaitForDeviceSettle</a> =  4, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652a4858a0b23977f4f77ea29edbc904b9fb">HOST_STATE_Powered_WaitForConnect</a> =  5, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652ae030c9688fb43e0b1d097ba1acacf854">HOST_STATE_Powered_DoReset</a> =  6, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652a7512c568e1f7596725f658439ec86b9e">HOST_STATE_Powered_ConfigPipe</a> =  7, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652a0b293216a566aa247b32f8da7748954c">HOST_STATE_Default</a> =  8, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652a50cd36b287c50e86f73aa765d44b731c">HOST_STATE_Default_PostReset</a> =  9, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652a0bdd6390e7f81a5a85a7092ec2bb5c6b">HOST_STATE_Default_PostAddressSet</a> =  10, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652a51d7c15c291ee1462b72ad6a32834917">HOST_STATE_Addressed</a> =  11, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652a7324691118a474c8f197405ba3f57d8b">HOST_STATE_Configured</a> =  12, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652a93fb0c683a07bcce4d5af58ef3f1845e">HOST_STATE_Suspended</a> =  15
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ga3e4d1d4775626c3d29543f4a3154d74d">USB_Host_ErrorCodes_t</a> { <a class="el" href="a00267.html#gga3e4d1d4775626c3d29543f4a3154d74dac4b5e8b0a3bfb8abf6c5a4f62b1901ce">HOST_ERROR_VBusVoltageDip</a> =  0
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ga647b09a2205a9beda86049b6b8f004a0">USB_Host_EnumerationErrorCodes_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#gga647b09a2205a9beda86049b6b8f004a0af109c8e2f136312daf33c3f24813075f">HOST_ENUMERROR_NoError</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#gga647b09a2205a9beda86049b6b8f004a0a1dae3bd36f1c5a9f5e106fff9a42cc66">HOST_ENUMERROR_WaitStage</a> =  1, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#gga647b09a2205a9beda86049b6b8f004a0a10683800ce0b14ee049c9a50fdc101b9">HOST_ENUMERROR_NoDeviceDetected</a> =  2, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#gga647b09a2205a9beda86049b6b8f004a0ad4e5a60748230db93193081b06e61a06">HOST_ENUMERROR_ControlError</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00267.html#gga647b09a2205a9beda86049b6b8f004a0aa54e1f3548f38b80968903c585710de0">HOST_ENUMERROR_PipeConfigError</a> =  4
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#gad1672ac648f7c9072615eb1f07e186f2">USB_Host_ResetBus</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ga45082826ccccf84ea990dbb3bd970b2e">USB_Host_IsBusResetComplete</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#gaab0e1e5d3d33552dc89b5a3c7c8c1561">USB_Host_ResumeBus</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#gad0e10b9558daf18dbce13325b1442e81">USB_Host_SuspendBus</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#gabe80fe778471cc3330a85cbe2b1c49c4">USB_Host_IsBusSuspended</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ga070aac37a76fa9bdc24bee0a6c9d41a0">USB_Host_IsDeviceFullSpeed</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#gaa99f5b1669047993ce810e45520dd9de">USB_Host_IsRemoteWakeupSent</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ga31700446d0f41b948af1db5569ef569d">USB_Host_ClearRemoteWakeupSent</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ga13e9ba05fc926a4b59690535ebeea755">USB_Host_ResumeFromWakeupRequest</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ga2bd9a29320127d7b4b1bd16c5f4c8b4b">USB_Host_IsResumeFromWakeupRequestSent</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ga089d8d7a9b075118ce6b070667e4c89f">USB_Host_SetDeviceConfiguration</a> (const uint8_t ConfigNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#gaab5464d90f1c6cd750f977b631d0bbf1">USB_Host_GetDeviceDescriptor</a> (void *const DeviceDescriptorPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ga1b0271f4b5e0e0829f091567005d8fb8">USB_Host_ClearPipeStall</a> (uint8_t EndpointIndex)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ga3a07df098dd21e61246a903a667aa5af">USB_HostState</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>USB Host mode related macros and enums. This module contains macros and enums which are used when the USB controller is initialized in host mode. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga4591576cd26d635aa5dfdf992ed99a3f"></a><!-- doxytag: member="Host.h::HOST_DEVICE_SETTLE_DELAY_MS" ref="ga4591576cd26d635aa5dfdf992ed99a3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HOST_DEVICE_SETTLE_DELAY_MS&nbsp;&nbsp;&nbsp;1500</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constant for the delay in milliseconds after a device is connected before the library will start the enumeration process. Some devices require a delay of up to 5 seconds after connection before the enumeration process can start or incorrect operation will occur.</p>
<p>This value may be overridden in the user project makefile as the value of the HOST_DEVICE_SETTLE_DELAY_MS token, and passed to the compiler using the -D switch. </p>

</div>
</div>
<a class="anchor" id="ga8233ed35f4abbb180ec8304ce483d406"></a><!-- doxytag: member="Host.h::USB_HOST_DEVICEADDRESS" ref="ga8233ed35f4abbb180ec8304ce483d406" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_HOST_DEVICEADDRESS&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicates the fixed USB device address which any attached device is enumerated to when in host mode. As only one USB device may be attached to the AVR in host mode at any one time and that the address used is not important (other than the fact that it is non-zero), a fixed value is specified by the library. </p>

</div>
</div>
<a class="anchor" id="ga97d683c3c4341eb303681e66058a8888"></a><!-- doxytag: member="Host.h::USB_HOST_TIMEOUT_MS" ref="ga97d683c3c4341eb303681e66058a8888" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_HOST_TIMEOUT_MS&nbsp;&nbsp;&nbsp;1000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constant for the maximum software timeout period of sent USB control transactions to an attached device. If a device fails to respond to a sent control request within this period, the library will return a timeout error code.</p>
<p>This value may be overridden in the user project makefile as the value of the <a class="el" href="a00267.html#ga97d683c3c4341eb303681e66058a8888">USB_HOST_TIMEOUT_MS</a> token, and passed to the compiler using the -D switch. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga647b09a2205a9beda86049b6b8f004a0"></a><!-- doxytag: member="Host.h::USB_Host_EnumerationErrorCodes_t" ref="ga647b09a2205a9beda86049b6b8f004a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00267.html#ga647b09a2205a9beda86049b6b8f004a0">USB_Host_EnumerationErrorCodes_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum for the error codes for the <a class="el" href="a00257.html#gae0b1e6afc2831ad33bda0b1c1d8f5825">EVENT_USB_Host_DeviceEnumerationFailed()</a> event.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00257.html">USB Events</a> for more information on this event. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga647b09a2205a9beda86049b6b8f004a0af109c8e2f136312daf33c3f24813075f"></a><!-- doxytag: member="HOST_ENUMERROR_NoError" ref="gga647b09a2205a9beda86049b6b8f004a0af109c8e2f136312daf33c3f24813075f" args="" -->HOST_ENUMERROR_NoError</em>&nbsp;</td><td>
<p>No error occurred. Used internally, this is not a valid ErrorCode parameter value for the <a class="el" href="a00257.html#gae0b1e6afc2831ad33bda0b1c1d8f5825">EVENT_USB_Host_DeviceEnumerationFailed()</a> event. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga647b09a2205a9beda86049b6b8f004a0a1dae3bd36f1c5a9f5e106fff9a42cc66"></a><!-- doxytag: member="HOST_ENUMERROR_WaitStage" ref="gga647b09a2205a9beda86049b6b8f004a0a1dae3bd36f1c5a9f5e106fff9a42cc66" args="" -->HOST_ENUMERROR_WaitStage</em>&nbsp;</td><td>
<p>One of the delays between enumeration steps failed to complete successfully, due to a timeout or other error. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga647b09a2205a9beda86049b6b8f004a0a10683800ce0b14ee049c9a50fdc101b9"></a><!-- doxytag: member="HOST_ENUMERROR_NoDeviceDetected" ref="gga647b09a2205a9beda86049b6b8f004a0a10683800ce0b14ee049c9a50fdc101b9" args="" -->HOST_ENUMERROR_NoDeviceDetected</em>&nbsp;</td><td>
<p>No device was detected, despite the USB data lines indicating the attachment of a device. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga647b09a2205a9beda86049b6b8f004a0ad4e5a60748230db93193081b06e61a06"></a><!-- doxytag: member="HOST_ENUMERROR_ControlError" ref="gga647b09a2205a9beda86049b6b8f004a0ad4e5a60748230db93193081b06e61a06" args="" -->HOST_ENUMERROR_ControlError</em>&nbsp;</td><td>
<p>One of the enumeration control requests failed to complete successfully. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga647b09a2205a9beda86049b6b8f004a0aa54e1f3548f38b80968903c585710de0"></a><!-- doxytag: member="HOST_ENUMERROR_PipeConfigError" ref="gga647b09a2205a9beda86049b6b8f004a0aa54e1f3548f38b80968903c585710de0" args="" -->HOST_ENUMERROR_PipeConfigError</em>&nbsp;</td><td>
<p>The default control pipe (address 0) failed to configure correctly. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e4d1d4775626c3d29543f4a3154d74d"></a><!-- doxytag: member="Host.h::USB_Host_ErrorCodes_t" ref="ga3e4d1d4775626c3d29543f4a3154d74d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00267.html#ga3e4d1d4775626c3d29543f4a3154d74d">USB_Host_ErrorCodes_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum for the error codes for the <a class="el" href="a00257.html#gacba95db728d0d4ffc4abaf4b1e9dc707">EVENT_USB_Host_HostError()</a> event.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00257.html">USB Events</a> for more information on this event. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga3e4d1d4775626c3d29543f4a3154d74dac4b5e8b0a3bfb8abf6c5a4f62b1901ce"></a><!-- doxytag: member="HOST_ERROR_VBusVoltageDip" ref="gga3e4d1d4775626c3d29543f4a3154d74dac4b5e8b0a3bfb8abf6c5a4f62b1901ce" args="" -->HOST_ERROR_VBusVoltageDip</em>&nbsp;</td><td>
<p>VBUS voltage dipped to an unacceptable level. This error may be the result of an attached device drawing too much current from the VBUS line, or due to the AVR's power source being unable to supply sufficient current. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa30175c751f951c44bf24fc901480652"></a><!-- doxytag: member="Host.h::USB_Host_States_t" ref="gaa30175c751f951c44bf24fc901480652" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00267.html#gaa30175c751f951c44bf24fc901480652">USB_Host_States_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum for the various states of the USB Host state machine. Only some states are implemented in the LUFA library - other states are left to the user to implement.</p>
<p>For information on each state, refer to the USB 2.0 specification. Some states have</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00267.html#ga3a07df098dd21e61246a903a667aa5af">USB_HostState</a>, which stores the current host state machine state. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaa30175c751f951c44bf24fc901480652af3f3f87924f879ce2395033b9affd999"></a><!-- doxytag: member="HOST_STATE_WaitForDeviceRemoval" ref="ggaa30175c751f951c44bf24fc901480652af3f3f87924f879ce2395033b9affd999" args="" -->HOST_STATE_WaitForDeviceRemoval</em>&nbsp;</td><td>
<p>Internally implemented by the library. This state can be used by the library to wait until the attached device is removed by the user - useful for when an error occurs or further communication with the device is not needed. This allows for other code to run while the state machine is effectively disabled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa30175c751f951c44bf24fc901480652a8bb200e2f9e667c5ae530fb635b793ee"></a><!-- doxytag: member="HOST_STATE_WaitForDevice" ref="ggaa30175c751f951c44bf24fc901480652a8bb200e2f9e667c5ae530fb635b793ee" args="" -->HOST_STATE_WaitForDevice</em>&nbsp;</td><td>
<p>Internally implemented by the library. This state indicates that the stack is waiting for an interval to elapse before continuing with the next step of the device enumeration process.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not manually change to this state in the user code. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa30175c751f951c44bf24fc901480652af95e1b584ddb58ca115bc7fbbc923ba0"></a><!-- doxytag: member="HOST_STATE_Unattached" ref="ggaa30175c751f951c44bf24fc901480652af95e1b584ddb58ca115bc7fbbc923ba0" args="" -->HOST_STATE_Unattached</em>&nbsp;</td><td>
<p>Internally implemented by the library. This state indicates that the host state machine is waiting for a device to be attached so that it can start the enumeration process.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not manually change to this state in the user code. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa30175c751f951c44bf24fc901480652af6c9134a477d97b02f0ceaf457b03302"></a><!-- doxytag: member="HOST_STATE_Powered" ref="ggaa30175c751f951c44bf24fc901480652af6c9134a477d97b02f0ceaf457b03302" args="" -->HOST_STATE_Powered</em>&nbsp;</td><td>
<p>Internally implemented by the library. This state indicates that a device has been attached, and the library's internals are being configured to begin the enumeration process.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not manually change to this state in the user code. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa30175c751f951c44bf24fc901480652a3059481e2036f4f398302f373b024cb7"></a><!-- doxytag: member="HOST_STATE_Powered_WaitForDeviceSettle" ref="ggaa30175c751f951c44bf24fc901480652a3059481e2036f4f398302f373b024cb7" args="" -->HOST_STATE_Powered_WaitForDeviceSettle</em>&nbsp;</td><td>
<p>Internally implemented by the library. This state indicates that the stack is waiting for the initial settling period to elapse before beginning the enumeration process.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not manually change to this state in the user code. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa30175c751f951c44bf24fc901480652a4858a0b23977f4f77ea29edbc904b9fb"></a><!-- doxytag: member="HOST_STATE_Powered_WaitForConnect" ref="ggaa30175c751f951c44bf24fc901480652a4858a0b23977f4f77ea29edbc904b9fb" args="" -->HOST_STATE_Powered_WaitForConnect</em>&nbsp;</td><td>
<p>Internally implemented by the library. This state indicates that the stack is waiting for a connection event from the USB controller to indicate a valid USB device has been attached to the bus and is ready to be enumerated.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not manually change to this state in the user code. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa30175c751f951c44bf24fc901480652ae030c9688fb43e0b1d097ba1acacf854"></a><!-- doxytag: member="HOST_STATE_Powered_DoReset" ref="ggaa30175c751f951c44bf24fc901480652ae030c9688fb43e0b1d097ba1acacf854" args="" -->HOST_STATE_Powered_DoReset</em>&nbsp;</td><td>
<p>Internally implemented by the library. This state indicates that a valid USB device has been attached, and that it is will now be reset to ensure it is ready for enumeration.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not manually change to this state in the user code. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa30175c751f951c44bf24fc901480652a7512c568e1f7596725f658439ec86b9e"></a><!-- doxytag: member="HOST_STATE_Powered_ConfigPipe" ref="ggaa30175c751f951c44bf24fc901480652a7512c568e1f7596725f658439ec86b9e" args="" -->HOST_STATE_Powered_ConfigPipe</em>&nbsp;</td><td>
<p>Internally implemented by the library. This state indicates that the attached device is currently powered and reset, and that the control pipe is now being configured by the stack.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not manually change to this state in the user code. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa30175c751f951c44bf24fc901480652a0b293216a566aa247b32f8da7748954c"></a><!-- doxytag: member="HOST_STATE_Default" ref="ggaa30175c751f951c44bf24fc901480652a0b293216a566aa247b32f8da7748954c" args="" -->HOST_STATE_Default</em>&nbsp;</td><td>
<p>Internally implemented by the library. This state indicates that the stack is currently retrieving the control endpoint's size from the device, so that the control pipe can be altered to match.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not manually change to this state in the user code. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa30175c751f951c44bf24fc901480652a50cd36b287c50e86f73aa765d44b731c"></a><!-- doxytag: member="HOST_STATE_Default_PostReset" ref="ggaa30175c751f951c44bf24fc901480652a50cd36b287c50e86f73aa765d44b731c" args="" -->HOST_STATE_Default_PostReset</em>&nbsp;</td><td>
<p>Internally implemented by the library. This state indicates that the control pipe is being reconfigured to match the retrieved control endpoint size from the device, and the device's USB bus address is being set.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not manually change to this state in the user code. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa30175c751f951c44bf24fc901480652a0bdd6390e7f81a5a85a7092ec2bb5c6b"></a><!-- doxytag: member="HOST_STATE_Default_PostAddressSet" ref="ggaa30175c751f951c44bf24fc901480652a0bdd6390e7f81a5a85a7092ec2bb5c6b" args="" -->HOST_STATE_Default_PostAddressSet</em>&nbsp;</td><td>
<p>Internally implemented by the library. This state indicates that the device's address has now been set, and the stack is has now completed the device enumeration process. This state causes the stack to change the current USB device address to that set for the connected device, before progressing to the user-implemented HOST_STATE_Addressed state for further communications.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Do not manually change to this state in the user code. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa30175c751f951c44bf24fc901480652a51d7c15c291ee1462b72ad6a32834917"></a><!-- doxytag: member="HOST_STATE_Addressed" ref="ggaa30175c751f951c44bf24fc901480652a51d7c15c291ee1462b72ad6a32834917" args="" -->HOST_STATE_Addressed</em>&nbsp;</td><td>
<p>May be implemented by the user project. This state should set the device configuration before progressing to the HOST_STATE_Configured state. Other processing (such as the retrieval and processing of the device descriptor) should also be placed in this state. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa30175c751f951c44bf24fc901480652a7324691118a474c8f197405ba3f57d8b"></a><!-- doxytag: member="HOST_STATE_Configured" ref="ggaa30175c751f951c44bf24fc901480652a7324691118a474c8f197405ba3f57d8b" args="" -->HOST_STATE_Configured</em>&nbsp;</td><td>
<p>May be implemented by the user project. This state should implement the actual work performed on the attached device and changed to the HOST_STATE_Suspended or HOST_STATE_WaitForDeviceRemoval states as needed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa30175c751f951c44bf24fc901480652a93fb0c683a07bcce4d5af58ef3f1845e"></a><!-- doxytag: member="HOST_STATE_Suspended" ref="ggaa30175c751f951c44bf24fc901480652a93fb0c683a07bcce4d5af58ef3f1845e" args="" -->HOST_STATE_Suspended</em>&nbsp;</td><td>
<p>May be implemented by the user project. This state should be maintained while the bus is suspended, and changed to either the HOST_STATE_Configured (after resuming the bus with the <a class="el" href="a00267.html#gaab0e1e5d3d33552dc89b5a3c7c8c1561">USB_Host_ResumeBus()</a> macro) or the HOST_STATE_WaitForDeviceRemoval states as needed. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga1b0271f4b5e0e0829f091567005d8fb8"></a><!-- doxytag: member="Host.h::USB_Host_ClearPipeStall" ref="ga1b0271f4b5e0e0829f091567005d8fb8" args="(uint8_t EndpointIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_Host_ClearPipeStall </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>EndpointIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears a stall condition on the given pipe, via a ClearFeature request to the attached device.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>After this routine returns, the control pipe will be selected.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>EndpointIndex</em>&nbsp;</td><td>Index of the endpoint to clear</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00275.html#gab48bdc395027a1729b8324ff6efa15ec">USB_Host_SendControlErrorCodes_t</a> enum to indicate the result. </dd></dl>

</div>
</div>
<a class="anchor" id="ga31700446d0f41b948af1db5569ef569d"></a><!-- doxytag: member="Host.h::USB_Host_ClearRemoteWakeupSent" ref="ga31700446d0f41b948af1db5569ef569d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_Host_ClearRemoteWakeupSent </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears the flag indicating that a Remote Wakeup request has been issued by an attached device. </p>

</div>
</div>
<a class="anchor" id="gaab5464d90f1c6cd750f977b631d0bbf1"></a><!-- doxytag: member="Host.h::USB_Host_GetDeviceDescriptor" ref="gaab5464d90f1c6cd750f977b631d0bbf1" args="(void *const DeviceDescriptorPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_Host_GetDeviceDescriptor </td>
          <td>(</td>
          <td class="paramtype">void *const &nbsp;</td>
          <td class="paramname"> <em>DeviceDescriptorPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience function. This routine sends a GetDescriptor standard request to the attached device, requesting the device descriptor. This can be used to easily retrieve information about the device such as its VID, PID and power requirements.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>After this routine returns, the control pipe will be selected.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>DeviceDescriptorPtr</em>&nbsp;</td><td>Pointer to the destination device descriptor structure where the read data is to be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00275.html#gab48bdc395027a1729b8324ff6efa15ec">USB_Host_SendControlErrorCodes_t</a> enum to indicate the result. </dd></dl>

</div>
</div>
<a class="anchor" id="ga45082826ccccf84ea990dbb3bd970b2e"></a><!-- doxytag: member="Host.h::USB_Host_IsBusResetComplete" ref="ga45082826ccccf84ea990dbb3bd970b2e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_Host_IsBusResetComplete </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if a previously issued bus reset (via the <a class="el" href="a00267.html#gad1672ac648f7c9072615eb1f07e186f2">USB_Host_ResetBus()</a> macro) has completed.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if no bus reset is currently being sent, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gabe80fe778471cc3330a85cbe2b1c49c4"></a><!-- doxytag: member="Host.h::USB_Host_IsBusSuspended" ref="gabe80fe778471cc3330a85cbe2b1c49c4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool USB_Host_IsBusSuspended </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if the USB bus has been suspended via the use of the <a class="el" href="a00267.html#gad0e10b9558daf18dbce13325b1442e81">USB_Host_SuspendBus()</a> macro, false otherwise. While suspended, no USB communications can occur until the bus is resumed, except for the Remote Wakeup event from the device if supported.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if the bus is currently suspended, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga070aac37a76fa9bdc24bee0a6c9d41a0"></a><!-- doxytag: member="Host.h::USB_Host_IsDeviceFullSpeed" ref="ga070aac37a76fa9bdc24bee0a6c9d41a0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool USB_Host_IsDeviceFullSpeed </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if the attached device is currently enumerated in Full Speed mode (12Mb/s), or false if the attached device is enumerated in Low Speed mode (1.5Mb/s).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if the attached device is enumerated in Full Speed mode, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gaa99f5b1669047993ce810e45520dd9de"></a><!-- doxytag: member="Host.h::USB_Host_IsRemoteWakeupSent" ref="gaa99f5b1669047993ce810e45520dd9de" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool USB_Host_IsRemoteWakeupSent </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if the attached device is currently issuing a Remote Wakeup request, requesting that the host resume the USB bus and wake up the device, false otherwise.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if the attached device has sent a Remote Wakeup request, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga2bd9a29320127d7b4b1bd16c5f4c8b4b"></a><!-- doxytag: member="Host.h::USB_Host_IsResumeFromWakeupRequestSent" ref="ga2bd9a29320127d7b4b1bd16c5f4c8b4b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool USB_Host_IsResumeFromWakeupRequestSent </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if a resume from Remote Wakeup request is currently being sent to an attached device.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if no resume request is currently being sent, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gad1672ac648f7c9072615eb1f07e186f2"></a><!-- doxytag: member="Host.h::USB_Host_ResetBus" ref="gad1672ac648f7c9072615eb1f07e186f2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_Host_ResetBus </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the USB bus, including the endpoints in any attached device and pipes on the AVR host. USB bus resets leave the default control pipe configured (if already configured).</p>
<p>If the USB bus has been suspended prior to issuing a bus reset, the attached device will be woken up automatically and the bus resumed after the reset has been correctly issued. </p>

</div>
</div>
<a class="anchor" id="gaab0e1e5d3d33552dc89b5a3c7c8c1561"></a><!-- doxytag: member="Host.h::USB_Host_ResumeBus" ref="gaab0e1e5d3d33552dc89b5a3c7c8c1561" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_Host_ResumeBus </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resumes USB communications with an attached and enumerated device, by resuming the transmission of the 1MS Start Of Frame messages to the device. When resumed, USB communications between the host and attached device may occur. </p>

</div>
</div>
<a class="anchor" id="ga13e9ba05fc926a4b59690535ebeea755"></a><!-- doxytag: member="Host.h::USB_Host_ResumeFromWakeupRequest" ref="ga13e9ba05fc926a4b59690535ebeea755" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_Host_ResumeFromWakeupRequest </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Accepts a Remote Wakeup request from an attached device. This must be issued in response to a device's Remote Wakeup request within 2ms for the request to be accepted and the bus to be resumed. </p>

</div>
</div>
<a class="anchor" id="ga089d8d7a9b075118ce6b070667e4c89f"></a><!-- doxytag: member="Host.h::USB_Host_SetDeviceConfiguration" ref="ga089d8d7a9b075118ce6b070667e4c89f" args="(const uint8_t ConfigNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USB_Host_SetDeviceConfiguration </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>ConfigNumber</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience function. This routine sends a SetConfiguration standard request to the attached device, with the given configuration index. This can be used to easily set the device configuration without creating and sending the request manually.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>After this routine returns, the control pipe will be selected.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ConfigNumber</em>&nbsp;</td><td>Configuration index to send to the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00275.html#gab48bdc395027a1729b8324ff6efa15ec">USB_Host_SendControlErrorCodes_t</a> enum to indicate the result. </dd></dl>

</div>
</div>
<a class="anchor" id="gad0e10b9558daf18dbce13325b1442e81"></a><!-- doxytag: member="Host.h::USB_Host_SuspendBus" ref="gad0e10b9558daf18dbce13325b1442e81" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_Host_SuspendBus </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspends the USB bus, preventing any communications from occurring between the host and attached device until the bus has been resumed. This stops the transmission of the 1MS Start Of Frame messages to the device. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga3a07df098dd21e61246a903a667aa5af"></a><!-- doxytag: member="USBTask.h::USB_HostState" ref="ga3a07df098dd21e61246a903a667aa5af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint8_t <a class="el" href="a00267.html#ga3a07df098dd21e61246a903a667aa5af">USB_HostState</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicates the current host state machine state. When in host mode, this indicates the state via one of the values of the <a class="el" href="a00267.html#gaa30175c751f951c44bf24fc901480652">USB_Host_States_t</a> enum values.</p>
<p>This value may be altered by the user application to implement the <a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652a51d7c15c291ee1462b72ad6a32834917">HOST_STATE_Addressed</a>, <a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652a7324691118a474c8f197405ba3f57d8b">HOST_STATE_Configured</a> and <a class="el" href="a00267.html#ggaa30175c751f951c44bf24fc901480652a93fb0c683a07bcce4d5af58ef3f1845e">HOST_STATE_Suspended</a> states which are not implemented by the library.</p>
<p>To reduce program size and speed up checks of this global, it can be placed into one of the AVR's GPIOR hardware registers instead of RAM by defining the HOST_STATE_AS_GPIOR token to a value between 0 and 2 in the project makefile and passing it to the compiler via the -D switch. When defined, the corresponding GPIOR register should not be used in the user application except implicitly via the library APIs.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This global is only present if the user application can be a USB host.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00267.html#gaa30175c751f951c44bf24fc901480652">USB_Host_States_t</a> for a list of possible device states </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 1 Dec 2009 for LUFA (Formerly MyUSB) Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
