<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LUFA (Formerly MyUSB) Library: Endpoint Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Endpoint Management<br/>
<small>
[<a class="el" href="a00276.html">USB - LUFA/Drivers/USB/USB.h</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00263.html">Endpoint Data Reading and Writing</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html">Read/Write of Primitive Data Types</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html">Read/Write of Multi-Byte Streams</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00266.html">Endpoint Packet Management</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#gab011e2ee1e9f55b60cda3dbc79b95961">ENDPOINT_DIR_OUT</a>&nbsp;&nbsp;&nbsp;(0 &lt;&lt; EPDIR)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#gabe19393ecfcac9ea1ee8c6b3dc87830a">ENDPOINT_DIR_IN</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; EPDIR)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#gae4bc67200452560b253e3f01acae9373">ENDPOINT_BANK_SINGLE</a>&nbsp;&nbsp;&nbsp;(0 &lt;&lt; EPBK0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ga417e96e8278a9c41e846fff106ce5791">ENDPOINT_BANK_DOUBLE</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; EPBK0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ga5735655e855a6da7ee2e48084c10d9d6">ENDPOINT_CONTROLEP</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#gaebe9cfe97e9292e5e8cfba9885bbd901">ENDPOINT_CONTROLEP_DEFAULT_SIZE</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ga6ee88e6fd992e2a064923871980b493d">ENDPOINT_EPNUM_MASK</a>&nbsp;&nbsp;&nbsp;0x07</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#gaafb7a906223f76d344a8ad05bf066f4c">ENDPOINT_EPSIZE_MASK</a>&nbsp;&nbsp;&nbsp;0x7FF</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#gacf9fb35663717d6cdf4edd73d33893dd">ENDPOINT_MAX_SIZE</a>(n)&nbsp;&nbsp;&nbsp;_ENDPOINT_GET_MAXSIZE(n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ga94e28d8a057800482e42435807ad9c16">ENDPOINT_DOUBLEBANK_SUPPORTED</a>(n)&nbsp;&nbsp;&nbsp;_ENDPOINT_GET_DOUBLEBANK(n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ga0aaeafaa974fb7095750a771e2adfc73">ENDPOINT_TOTAL_ENDPOINTS</a>&nbsp;&nbsp;&nbsp;7</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#gaeb16d0613fb742663f6fef589d143f45">Endpoint_GetCurrentEndpoint</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#gaf162d6a78fe9ae002ea51a95d9424c0a">Endpoint_SelectEndpoint</a> (uint8_t EndpointNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ga179c50ddc489dfb41e19efe189785e0b">Endpoint_ResetFIFO</a> (uint8_t EndpointNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ga383e138eeeded34090fbc4f41d47872d">Endpoint_EnableEndpoint</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ga26000072bff8a7feaa0f64fbedc67f5f">Endpoint_DisableEndpoint</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#gadd8f79933c91ab076e5fa78a2ca7dd1f">Endpoint_IsEnabled</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ga14786993ad0006ed489d16f75fe6c2ea">Endpoint_IsConfigured</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#gacc3e056fbed373a484bc55da6cad1ebd">Endpoint_GetEndpointInterrupts</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#gaa2de32aeb330918d7f5f5bf486ce8a40">Endpoint_HasEndpointInterrupted</a> (uint8_t EndpointNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#gadb1cbdb84d80aa2e09603b2b5a728399">Endpoint_ResetDataToggle</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#gad5c494e7504ece2015471bea9489219d">Endpoint_GetEndpointDirection</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ga73e11a37553269715f5f0011ea7392d6">Endpoint_SetEndpointDirection</a> (uint8_t DirectionMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ga68a16ef473270536379b150302d3dfff">Endpoint_ConfigureEndpoint</a> (const uint8_t Number, const uint8_t Type, const uint8_t Direction, const uint16_t Size, const uint8_t Banks)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ga9e00020d1fca630c351e3b8139ba67df">Endpoint_ClearStatusStage</a> (void)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ga8422610dc18164a09618d82b9306c365">USB_ControlEndpointSize</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Functions, macros and enums related to endpoint management when in USB Device mode. This module contains the endpoint management macros, as well as endpoint interrupt and data send/receive functions for various data types. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga417e96e8278a9c41e846fff106ce5791"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_BANK_DOUBLE" ref="ga417e96e8278a9c41e846fff106ce5791" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_BANK_DOUBLE&nbsp;&nbsp;&nbsp;(1 &lt;&lt; EPBK0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mask for the bank mode selection for the <a class="el" href="a00262.html#ga68a16ef473270536379b150302d3dfff">Endpoint_ConfigureEndpoint()</a> macro. This indicates that the endpoint should have two banks, which requires more USB FIFO memory but results in faster transfers as one USB device (the AVR or the host) can access one bank while the other accesses the second bank. </p>

</div>
</div>
<a class="anchor" id="gae4bc67200452560b253e3f01acae9373"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_BANK_SINGLE" ref="gae4bc67200452560b253e3f01acae9373" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_BANK_SINGLE&nbsp;&nbsp;&nbsp;(0 &lt;&lt; EPBK0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mask for the bank mode selection for the <a class="el" href="a00262.html#ga68a16ef473270536379b150302d3dfff">Endpoint_ConfigureEndpoint()</a> macro. This indicates that the endpoint should have one single bank, which requires less USB FIFO memory but results in slower transfers as only one USB device (the AVR or the host) can access the endpoint's bank at the one time. </p>

</div>
</div>
<a class="anchor" id="ga5735655e855a6da7ee2e48084c10d9d6"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_CONTROLEP" ref="ga5735655e855a6da7ee2e48084c10d9d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_CONTROLEP&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint address for the default control endpoint, which always resides in address 0. This is defined for convenience to give more readable code when used with the endpoint macros. </p>

</div>
</div>
<a class="anchor" id="gaebe9cfe97e9292e5e8cfba9885bbd901"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_CONTROLEP_DEFAULT_SIZE" ref="gaebe9cfe97e9292e5e8cfba9885bbd901" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_CONTROLEP_DEFAULT_SIZE&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default size of the default control endpoint's bank, until altered by the Endpoint0Size value in the device descriptor. Not available if the FIXED_CONTROL_ENDPOINT_SIZE token is defined. </p>

</div>
</div>
<a class="anchor" id="gabe19393ecfcac9ea1ee8c6b3dc87830a"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_DIR_IN" ref="gabe19393ecfcac9ea1ee8c6b3dc87830a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_DIR_IN&nbsp;&nbsp;&nbsp;(1 &lt;&lt; EPDIR)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint data direction mask for <a class="el" href="a00262.html#ga68a16ef473270536379b150302d3dfff">Endpoint_ConfigureEndpoint()</a>. This indicates that the endpoint should be initialized in the IN direction - i.e. data flows from device to host. </p>

</div>
</div>
<a class="anchor" id="gab011e2ee1e9f55b60cda3dbc79b95961"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_DIR_OUT" ref="gab011e2ee1e9f55b60cda3dbc79b95961" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_DIR_OUT&nbsp;&nbsp;&nbsp;(0 &lt;&lt; EPDIR)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint data direction mask for <a class="el" href="a00262.html#ga68a16ef473270536379b150302d3dfff">Endpoint_ConfigureEndpoint()</a>. This indicates that the endpoint should be initialized in the OUT direction - i.e. data flows from host to device. </p>

</div>
</div>
<a class="anchor" id="ga94e28d8a057800482e42435807ad9c16"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_DOUBLEBANK_SUPPORTED" ref="ga94e28d8a057800482e42435807ad9c16" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_DOUBLEBANK_SUPPORTED</td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;_ENDPOINT_GET_DOUBLEBANK(n)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicates if the given endpoint supports double banking.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>Endpoint number, a value between 0 and (ENDPOINT_TOTAL_ENDPOINTS - 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6ee88e6fd992e2a064923871980b493d"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_EPNUM_MASK" ref="ga6ee88e6fd992e2a064923871980b493d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_EPNUM_MASK&nbsp;&nbsp;&nbsp;0x07</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint number mask, for masking against endpoint addresses to retrieve the endpoint's numerical address in the device. </p>

</div>
</div>
<a class="anchor" id="gaafb7a906223f76d344a8ad05bf066f4c"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_EPSIZE_MASK" ref="gaafb7a906223f76d344a8ad05bf066f4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_EPSIZE_MASK&nbsp;&nbsp;&nbsp;0x7FF</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint bank size mask, for masking against endpoint addresses to retrieve the endpoint's bank size in the device. </p>

</div>
</div>
<a class="anchor" id="gacf9fb35663717d6cdf4edd73d33893dd"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_MAX_SIZE" ref="gacf9fb35663717d6cdf4edd73d33893dd" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_MAX_SIZE</td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;_ENDPOINT_GET_MAXSIZE(n)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum size in bytes of a given endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>Endpoint number, a value between 0 and (ENDPOINT_TOTAL_ENDPOINTS - 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0aaeafaa974fb7095750a771e2adfc73"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_TOTAL_ENDPOINTS" ref="ga0aaeafaa974fb7095750a771e2adfc73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_TOTAL_ENDPOINTS&nbsp;&nbsp;&nbsp;7</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Total number of endpoints (including the default control endpoint at address 0) which may be used in the device. Different USB AVR models support different amounts of endpoints, this value reflects the maximum number of endpoints for the currently selected AVR model. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga9e00020d1fca630c351e3b8139ba67df"></a><!-- doxytag: member="Endpoint.h::Endpoint_ClearStatusStage" ref="ga9e00020d1fca630c351e3b8139ba67df" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Endpoint_ClearStatusStage </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Completes the status stage of a control transfer on a CONTROL type endpoint automatically, with respect to the data direction. This is a convenience function which can be used to simplify user control request handling. </p>

</div>
</div>
<a class="anchor" id="ga68a16ef473270536379b150302d3dfff"></a><!-- doxytag: member="Endpoint.h::Endpoint_ConfigureEndpoint" ref="ga68a16ef473270536379b150302d3dfff" args="(const uint8_t Number, const uint8_t Type, const uint8_t Direction, const uint16_t Size, const uint8_t Banks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Endpoint_ConfigureEndpoint </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>Number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>Direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>Banks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures the specified endpoint number with the given endpoint type, direction, bank size and banking mode. Endpoints should be allocated in ascending order by their address in the device (i.e. endpoint 1 should be configured before endpoint 2 and so on) to prevent fragmentation of the USB FIFO memory.</p>
<p>The endpoint type may be one of the EP_TYPE_* macros listed in <a class="el" href="a00157.html">LowLevel.h</a> and the direction may be either <a class="el" href="a00262.html#gab011e2ee1e9f55b60cda3dbc79b95961">ENDPOINT_DIR_OUT</a> or <a class="el" href="a00262.html#gabe19393ecfcac9ea1ee8c6b3dc87830a">ENDPOINT_DIR_IN</a>.</p>
<p>The bank size must indicate the maximum packet size that the endpoint can handle. Different endpoint numbers can handle different maximum packet sizes - refer to the chosen USB AVR's datasheet to determine the maximum bank size for each endpoint.</p>
<p>The banking mode may be either <a class="el" href="a00262.html#gae4bc67200452560b253e3f01acae9373">ENDPOINT_BANK_SINGLE</a> or <a class="el" href="a00262.html#ga417e96e8278a9c41e846fff106ce5791">ENDPOINT_BANK_DOUBLE</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The default control endpoint does not have to be manually configured, as it is automatically configured by the library internally.</dd>
<dd>
This routine will select the specified endpoint, and the endpoint will remain selected once the routine completes regardless of if the endpoint configuration succeeds.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if the configuration succeeded, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga26000072bff8a7feaa0f64fbedc67f5f"></a><!-- doxytag: member="Endpoint.h::Endpoint_DisableEndpoint" ref="ga26000072bff8a7feaa0f64fbedc67f5f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_DisableEndpoint </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables the currently selected endpoint so that data cannot be sent and received through it to and from a host. </p>

</div>
</div>
<a class="anchor" id="ga383e138eeeded34090fbc4f41d47872d"></a><!-- doxytag: member="Endpoint.h::Endpoint_EnableEndpoint" ref="ga383e138eeeded34090fbc4f41d47872d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_EnableEndpoint </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables the currently selected endpoint so that data can be sent and received through it to and from a host.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Endpoints must first be configured properly via <a class="el" href="a00262.html#ga68a16ef473270536379b150302d3dfff">Endpoint_ConfigureEndpoint()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb16d0613fb742663f6fef589d143f45"></a><!-- doxytag: member="Endpoint.h::Endpoint_GetCurrentEndpoint" ref="gaeb16d0613fb742663f6fef589d143f45" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t Endpoint_GetCurrentEndpoint </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the endpoint address of the currently selected endpoint. This is typically used to save the currently selected endpoint number so that it can be restored after another endpoint has been manipulated.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Index of the currently selected endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="gad5c494e7504ece2015471bea9489219d"></a><!-- doxytag: member="Endpoint.h::Endpoint_GetEndpointDirection" ref="gad5c494e7504ece2015471bea9489219d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t Endpoint_GetEndpointDirection </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines the currently selected endpoint's direction.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The currently selected endpoint's direction, as a ENDPOINT_DIR_* mask. </dd></dl>

</div>
</div>
<a class="anchor" id="gacc3e056fbed373a484bc55da6cad1ebd"></a><!-- doxytag: member="Endpoint.h::Endpoint_GetEndpointInterrupts" ref="gacc3e056fbed373a484bc55da6cad1ebd" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t Endpoint_GetEndpointInterrupts </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a mask indicating which INTERRUPT type endpoints have interrupted - i.e. their interrupt duration has elapsed. Which endpoints have interrupted can be determined by masking the return value against (1 &lt;&lt; {Endpoint Number}).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Mask whose bits indicate which endpoints have interrupted </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2de32aeb330918d7f5f5bf486ce8a40"></a><!-- doxytag: member="Endpoint.h::Endpoint_HasEndpointInterrupted" ref="gaa2de32aeb330918d7f5f5bf486ce8a40" args="(uint8_t EndpointNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Endpoint_HasEndpointInterrupted </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>EndpointNumber</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if the specified endpoint number has interrupted (valid only for INTERRUPT type endpoints).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>EndpointNumber</em>&nbsp;</td><td>Index of the endpoint whose interrupt flag should be tested</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if the specified endpoint has interrupted, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga14786993ad0006ed489d16f75fe6c2ea"></a><!-- doxytag: member="Endpoint.h::Endpoint_IsConfigured" ref="ga14786993ad0006ed489d16f75fe6c2ea" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Endpoint_IsConfigured </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if the currently selected endpoint is configured.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if the currently selected endpoint has been configured, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gadd8f79933c91ab076e5fa78a2ca7dd1f"></a><!-- doxytag: member="Endpoint.h::Endpoint_IsEnabled" ref="gadd8f79933c91ab076e5fa78a2ca7dd1f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Endpoint_IsEnabled </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if the currently selected endpoint is enabled, but not necessarily configured.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean True if the currently selected endpoint is enabled, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gadb1cbdb84d80aa2e09603b2b5a728399"></a><!-- doxytag: member="Endpoint.h::Endpoint_ResetDataToggle" ref="gadb1cbdb84d80aa2e09603b2b5a728399" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_ResetDataToggle </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the data toggle of the currently selected endpoint. </p>

</div>
</div>
<a class="anchor" id="ga179c50ddc489dfb41e19efe189785e0b"></a><!-- doxytag: member="Endpoint.h::Endpoint_ResetFIFO" ref="ga179c50ddc489dfb41e19efe189785e0b" args="(uint8_t EndpointNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_ResetFIFO </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>EndpointNumber</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the endpoint bank FIFO. This clears all the endpoint banks and resets the USB controller's In and Out pointers to the bank's contents.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>EndpointNumber</em>&nbsp;</td><td>Endpoint number whose FIFO buffers are to be reset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf162d6a78fe9ae002ea51a95d9424c0a"></a><!-- doxytag: member="Endpoint.h::Endpoint_SelectEndpoint" ref="gaf162d6a78fe9ae002ea51a95d9424c0a" args="(uint8_t EndpointNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_SelectEndpoint </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>EndpointNumber</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Selects the given endpoint number. If the address from the device descriptors is used, the value should be masked with the <a class="el" href="a00262.html#ga6ee88e6fd992e2a064923871980b493d">ENDPOINT_EPNUM_MASK</a> constant to extract only the endpoint number (and discarding the endpoint direction bit).</p>
<p>Any endpoint operations which do not require the endpoint number to be indicated will operate on the currently selected endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>EndpointNumber</em>&nbsp;</td><td>Endpoint number to select </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga73e11a37553269715f5f0011ea7392d6"></a><!-- doxytag: member="Endpoint.h::Endpoint_SetEndpointDirection" ref="ga73e11a37553269715f5f0011ea7392d6" args="(uint8_t DirectionMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_SetEndpointDirection </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>DirectionMask</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the direction of the currently selected endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>DirectionMask</em>&nbsp;</td><td>New endpoint direction, as a ENDPOINT_DIR_* mask. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga8422610dc18164a09618d82b9306c365"></a><!-- doxytag: member="Endpoint.h::USB_ControlEndpointSize" ref="ga8422610dc18164a09618d82b9306c365" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="a00262.html#ga8422610dc18164a09618d82b9306c365">USB_ControlEndpointSize</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Global indicating the maximum packet size of the default control endpoint located at address 0 in the device. This value is set to the value indicated in the device descriptor in the user project once the USB interface is initialized into device mode.</p>
<p>If space is an issue, it is possible to fix this to a static value by defining the control endpoint size in the FIXED_CONTROL_ENDPOINT_SIZE token passed to the compiler in the makefile via the -D switch. When a fixed control endpoint size is used, the size is no longer dynamically read from the descriptors at runtime and instead fixed to the given value. When used, it is important that the descriptor control endpoint size value matches the size given as the FIXED_CONTROL_ENDPOINT_SIZE token - it is recommended that the FIXED_CONTROL_ENDPOINT_SIZE token be used in the descriptors to ensure this.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This variable should be treated as read-only in the user application, and never manually changed in value. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 1 Dec 2009 for LUFA (Formerly MyUSB) Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
