<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LUFA (Formerly MyUSB) Library: Read/Write of Multi-Byte Streams</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Read/Write of Multi-Byte Streams<br/>
<small>
[<a class="el" href="a00262.html">Endpoint Management</a>,&nbsp;<a class="el" href="a00263.html">Endpoint Data Reading and Writing</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="a00265.html#gga7f0d584afdd478f8fdf20b9daf58394ba6acf368d991bdd879f9ca07f728b5e7d">ENDPOINT_RWSTREAM_NoError</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00265.html#gga7f0d584afdd478f8fdf20b9daf58394ba9ee2b85cf68389eeb60b4e0966b25bf6">ENDPOINT_RWSTREAM_EndpointStalled</a> =  1, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00265.html#gga7f0d584afdd478f8fdf20b9daf58394ba40895392d847a576af29ab69fd1f5555">ENDPOINT_RWSTREAM_DeviceDisconnected</a> =  2, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00265.html#gga7f0d584afdd478f8fdf20b9daf58394baf1ac37479c8b6188aba0c7fb4c0a5270">ENDPOINT_RWSTREAM_Timeout</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00265.html#gga7f0d584afdd478f8fdf20b9daf58394ba4d93ed7f5554fdd984417966ecbe171d">ENDPOINT_RWSTREAM_CallbackAborted</a> =  4
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="a00265.html#gga35e8041496378a7109b95dadcf1326c1a5d62d8e12a05e48b5256a54ad375df50">ENDPOINT_RWCSTREAM_NoError</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00265.html#gga35e8041496378a7109b95dadcf1326c1ace2fc9834ca3237b6c1e76ddfffca61f">ENDPOINT_RWCSTREAM_HostAborted</a> =  1, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00265.html#gga35e8041496378a7109b95dadcf1326c1a67bccf6a0309aaa98170ba65f6c5f24b">ENDPOINT_RWCSTREAM_DeviceDisconnected</a> =  2
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#gaee97ee5eaa468fdeeed3ac74c01b50af">Endpoint_Discard_Stream</a> (uint16_t Length, <a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#gaa992872885b95569746ea6408b7feca3">Endpoint_Write_Stream_LE</a> (const void *Buffer, uint16_t Length, <a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#gabbbc488c3165e1c06ddf3f12ef02e912">Endpoint_Write_EStream_LE</a> (const void *Buffer, uint16_t Length, <a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#gacb0df03d9583e45de27ddf7f380ca571">Endpoint_Write_PStream_LE</a> (const void *Buffer, uint16_t Length, <a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#ga9d862432fdc00bae0f98779dd7dbd3eb">Endpoint_Write_Stream_BE</a> (const void *Buffer, uint16_t Length, <a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#ga86c80298666003b7288d83f9b0c7789f">Endpoint_Write_EStream_BE</a> (const void *Buffer, uint16_t Length, <a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#ga95dd14a0bfda413971fb258f415b1944">Endpoint_Write_PStream_BE</a> (const void *Buffer, uint16_t Length, <a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#gaeb28eede8a5481350168e9b1940ecde1">Endpoint_Read_Stream_LE</a> (void *Buffer, uint16_t Length, <a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#ga2f5df36da0a9dda73d4e3d2f6f6b2b4c">Endpoint_Read_EStream_LE</a> (void *Buffer, uint16_t Length, <a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#gabcda08dc360ad439c4c72c2c1a666de3">Endpoint_Read_Stream_BE</a> (void *Buffer, uint16_t Length, <a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#ga16fb63523d9ca248d7f4606da3afaf61">Endpoint_Read_EStream_BE</a> (void *Buffer, uint16_t Length, <a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#gab28db1e015f6ccb22987551f0b4b7bb4">Endpoint_Write_Control_Stream_LE</a> (const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#ga6908d159f2a3357d9979624f63dee083">Endpoint_Write_Control_EStream_LE</a> (const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#ga2ed035b5ed4f675bc38c2d447d3d3256">Endpoint_Write_Control_PStream_LE</a> (const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#gae2ebee942dae1fe0fb6406583758a101">Endpoint_Write_Control_Stream_BE</a> (const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#gadd64c4b97c069a1ecab07e8c1817210b">Endpoint_Write_Control_EStream_BE</a> (const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#gaf3d834febafcea300d6562ff28c84625">Endpoint_Write_Control_PStream_BE</a> (const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#gae50541f5ff5f00d579ab99b09d73809d">Endpoint_Read_Control_Stream_LE</a> (void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#ga4d27810becdfebb9186847cd8ecad6b9">Endpoint_Read_Control_EStream_LE</a> (void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#gabe8bb452cbe61c11ffeadc352463d00d">Endpoint_Read_Control_Stream_BE</a> (void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html#ga94ad95e9604beb721512e50cd2056ae6">Endpoint_Read_Control_EStream_BE</a> (void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Functions, macros, variables, enums and types related to data reading and writing of data streams from and to endpoints. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga35e8041496378a7109b95dadcf1326c1"></a><!-- doxytag: member="Endpoint.h::Endpoint_ControlStream_RW_ErrorCodes_t" ref="ga35e8041496378a7109b95dadcf1326c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00265.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum for the possible error return codes of the Endpoint_*_Control_Stream_* functions.. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga35e8041496378a7109b95dadcf1326c1a5d62d8e12a05e48b5256a54ad375df50"></a><!-- doxytag: member="ENDPOINT_RWCSTREAM_NoError" ref="gga35e8041496378a7109b95dadcf1326c1a5d62d8e12a05e48b5256a54ad375df50" args="" -->ENDPOINT_RWCSTREAM_NoError</em>&nbsp;</td><td>
<p>Command completed successfully, no error. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga35e8041496378a7109b95dadcf1326c1ace2fc9834ca3237b6c1e76ddfffca61f"></a><!-- doxytag: member="ENDPOINT_RWCSTREAM_HostAborted" ref="gga35e8041496378a7109b95dadcf1326c1ace2fc9834ca3237b6c1e76ddfffca61f" args="" -->ENDPOINT_RWCSTREAM_HostAborted</em>&nbsp;</td><td>
<p>The aborted the transfer prematurely. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga35e8041496378a7109b95dadcf1326c1a67bccf6a0309aaa98170ba65f6c5f24b"></a><!-- doxytag: member="ENDPOINT_RWCSTREAM_DeviceDisconnected" ref="gga35e8041496378a7109b95dadcf1326c1a67bccf6a0309aaa98170ba65f6c5f24b" args="" -->ENDPOINT_RWCSTREAM_DeviceDisconnected</em>&nbsp;</td><td>
<p>Device was disconnected from the host during the transfer. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7f0d584afdd478f8fdf20b9daf58394b"></a><!-- doxytag: member="Endpoint.h::Endpoint_Stream_RW_ErrorCodes_t" ref="ga7f0d584afdd478f8fdf20b9daf58394b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00265.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum for the possible error return codes of the Endpoint_*_Stream_* functions. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga7f0d584afdd478f8fdf20b9daf58394ba6acf368d991bdd879f9ca07f728b5e7d"></a><!-- doxytag: member="ENDPOINT_RWSTREAM_NoError" ref="gga7f0d584afdd478f8fdf20b9daf58394ba6acf368d991bdd879f9ca07f728b5e7d" args="" -->ENDPOINT_RWSTREAM_NoError</em>&nbsp;</td><td>
<p>Command completed successfully, no error. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7f0d584afdd478f8fdf20b9daf58394ba9ee2b85cf68389eeb60b4e0966b25bf6"></a><!-- doxytag: member="ENDPOINT_RWSTREAM_EndpointStalled" ref="gga7f0d584afdd478f8fdf20b9daf58394ba9ee2b85cf68389eeb60b4e0966b25bf6" args="" -->ENDPOINT_RWSTREAM_EndpointStalled</em>&nbsp;</td><td>
<p>The endpoint was stalled during the stream transfer by the host or device. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7f0d584afdd478f8fdf20b9daf58394ba40895392d847a576af29ab69fd1f5555"></a><!-- doxytag: member="ENDPOINT_RWSTREAM_DeviceDisconnected" ref="gga7f0d584afdd478f8fdf20b9daf58394ba40895392d847a576af29ab69fd1f5555" args="" -->ENDPOINT_RWSTREAM_DeviceDisconnected</em>&nbsp;</td><td>
<p>Device was disconnected from the host during the transfer. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7f0d584afdd478f8fdf20b9daf58394baf1ac37479c8b6188aba0c7fb4c0a5270"></a><!-- doxytag: member="ENDPOINT_RWSTREAM_Timeout" ref="gga7f0d584afdd478f8fdf20b9daf58394baf1ac37479c8b6188aba0c7fb4c0a5270" args="" -->ENDPOINT_RWSTREAM_Timeout</em>&nbsp;</td><td>
<p>The host failed to accept or send the next packet within the software timeout period set by the <a class="el" href="a00268.html#gaaebc1f2021ec7fe55f6a493ac28ebcee">USB_STREAM_TIMEOUT_MS</a> macro. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7f0d584afdd478f8fdf20b9daf58394ba4d93ed7f5554fdd984417966ecbe171d"></a><!-- doxytag: member="ENDPOINT_RWSTREAM_CallbackAborted" ref="gga7f0d584afdd478f8fdf20b9daf58394ba4d93ed7f5554fdd984417966ecbe171d" args="" -->ENDPOINT_RWSTREAM_CallbackAborted</em>&nbsp;</td><td>
<p>Indicates that the stream's callback function aborted the transfer early. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaee97ee5eaa468fdeeed3ac74c01b50af"></a><!-- doxytag: member="Endpoint.h::Endpoint_Discard_Stream" ref="gaee97ee5eaa468fdeeed3ac74c01b50af" args="(uint16_t Length, StreamCallbackPtr_t Callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Discard_Stream </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads and discards the given number of bytes from the endpoint from the given buffer, discarding fully read packets from the host as needed. The last packet is not automatically discarded once the remaining bytes has been read; the user is responsible for manually discarding the last packet from the host via the <a class="el" href="a00266.html#ga3e46b62f81211da48ab96d4d1183855f">Endpoint_ClearOUT()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the next packet is ready, allowing for early aborts of stream transfers.</p>
<p>The callback routine should be created according to the information in <a class="el" href="a00260.html">Endpoint and Pipe Stream Callbacks</a>. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter omitted.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected endpoint. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga94ad95e9604beb721512e50cd2056ae6"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Control_EStream_BE" ref="ga94ad95e9604beb721512e50cd2056ae6" args="(void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Control_EStream_BE </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="a00265.html#gabe8bb452cbe61c11ffeadc352463d00d">Endpoint_Read_Control_Stream_BE()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function automatically clears the control transfer's status stage. Do not manually attempt to clear the status stage when using this routine in a control transaction.</dd>
<dd>
This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d27810becdfebb9186847cd8ecad6b9"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Control_EStream_LE" ref="ga4d27810becdfebb9186847cd8ecad6b9" args="(void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Control_EStream_LE </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="a00265.html#gae50541f5ff5f00d579ab99b09d73809d">Endpoint_Read_Control_Stream_LE()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function automatically clears the control transfer's status stage. Do not manually attempt to clear the status stage when using this routine in a control transaction.</dd>
<dd>
This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gabe8bb452cbe61c11ffeadc352463d00d"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Control_Stream_BE" ref="gabe8bb452cbe61c11ffeadc352463d00d" args="(void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Control_Stream_BE </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the given number of bytes from the CONTROL endpoint from the given buffer in big endian, discarding fully read packets from the host as needed. The device IN acknowledgement is not automatically sent after success or failure states; the user is responsible for manually sending the setup IN to finalize the transfer via the <a class="el" href="a00266.html#ga7a18211c2800d663a4ef99b5da8f1483">Endpoint_ClearIN()</a> macro.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function automatically clears the control transfer's status stage. Do not manually attempt to clear the status stage when using this routine in a control transaction.</dd>
<dd>
This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gae50541f5ff5f00d579ab99b09d73809d"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Control_Stream_LE" ref="gae50541f5ff5f00d579ab99b09d73809d" args="(void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Control_Stream_LE </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the given number of bytes from the CONTROL endpoint from the given buffer in little endian, discarding fully read packets from the host as needed. The device IN acknowledgement is not automatically sent after success or failure states; the user is responsible for manually sending the setup IN to finalize the transfer via the <a class="el" href="a00266.html#ga7a18211c2800d663a4ef99b5da8f1483">Endpoint_ClearIN()</a> macro.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function automatically clears the control transfer's status stage. Do not manually attempt to clear the status stage when using this routine in a control transaction.</dd>
<dd>
This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga16fb63523d9ca248d7f4606da3afaf61"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_EStream_BE" ref="ga16fb63523d9ca248d7f4606da3afaf61" args="(void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_EStream_BE </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="a00265.html#gabcda08dc360ad439c4c72c2c1a666de3">Endpoint_Read_Stream_BE()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the destination data buffer to write to, located in EEPROM memory space. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected endpoint. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2f5df36da0a9dda73d4e3d2f6f6b2b4c"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_EStream_LE" ref="ga2f5df36da0a9dda73d4e3d2f6f6b2b4c" args="(void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_EStream_LE </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="a00265.html#gaeb28eede8a5481350168e9b1940ecde1">Endpoint_Read_Stream_LE()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the destination data buffer to write to, located in EEPROM memory space. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected endpoint. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gabcda08dc360ad439c4c72c2c1a666de3"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Stream_BE" ref="gabcda08dc360ad439c4c72c2c1a666de3" args="(void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Stream_BE </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the given number of bytes from the endpoint from the given buffer in big endian, discarding fully read packets from the host as needed. The last packet is not automatically discarded once the remaining bytes has been read; the user is responsible for manually discarding the last packet from the host via the <a class="el" href="a00266.html#ga3e46b62f81211da48ab96d4d1183855f">Endpoint_ClearOUT()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the endpoint is ready to accept the next packet, allowing for early aborts of stream transfers.</p>
<p>The callback routine should be created according to the information in <a class="el" href="a00260.html">Endpoint and Pipe Stream Callbacks</a>. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter omitted.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected endpoint. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb28eede8a5481350168e9b1940ecde1"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Stream_LE" ref="gaeb28eede8a5481350168e9b1940ecde1" args="(void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Stream_LE </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the given number of bytes from the endpoint from the given buffer in little endian, discarding fully read packets from the host as needed. The last packet is not automatically discarded once the remaining bytes has been read; the user is responsible for manually discarding the last packet from the host via the <a class="el" href="a00266.html#ga3e46b62f81211da48ab96d4d1183855f">Endpoint_ClearOUT()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the endpoint is ready to accept the next packet, allowing for early aborts of stream transfers.</p>
<p>The callback routine should be created according to the information in <a class="el" href="a00260.html">Endpoint and Pipe Stream Callbacks</a>. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter omitted.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected endpoint. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gadd64c4b97c069a1ecab07e8c1817210b"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Control_EStream_BE" ref="gadd64c4b97c069a1ecab07e8c1817210b" args="(const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Control_EStream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="a00265.html#gae2ebee942dae1fe0fb6406583758a101">Endpoint_Write_Control_Stream_BE()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function automatically clears the control transfer's status stage. Do not manually attempt to clear the status stage when using this routine in a control transaction.</dd>
<dd>
This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6908d159f2a3357d9979624f63dee083"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Control_EStream_LE" ref="ga6908d159f2a3357d9979624f63dee083" args="(const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Control_EStream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>EEPROM buffer source version of Endpoint_Write_Control_Stream_LE.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function automatically clears the control transfer's status stage. Do not manually attempt to clear the status stage when using this routine in a control transaction.</dd>
<dd>
This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3d834febafcea300d6562ff28c84625"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Control_PStream_BE" ref="gaf3d834febafcea300d6562ff28c84625" args="(const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Control_PStream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>FLASH buffer source version of <a class="el" href="a00265.html#gae2ebee942dae1fe0fb6406583758a101">Endpoint_Write_Control_Stream_BE()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function automatically clears the control transfer's status stage. Do not manually attempt to clear the status stage when using this routine in a control transaction.</dd>
<dd>
The FLASH data must be located in the first 64KB of FLASH for this function to work correctly.</dd>
<dd>
This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ed035b5ed4f675bc38c2d447d3d3256"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Control_PStream_LE" ref="ga2ed035b5ed4f675bc38c2d447d3d3256" args="(const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Control_PStream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>FLASH buffer source version of <a class="el" href="a00265.html#gab28db1e015f6ccb22987551f0b4b7bb4">Endpoint_Write_Control_Stream_LE()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function automatically clears the control transfer's status stage. Do not manually attempt to clear the status stage when using this routine in a control transaction.</dd>
<dd>
The FLASH data must be located in the first 64KB of FLASH for this function to work correctly.</dd>
<dd>
This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gae2ebee942dae1fe0fb6406583758a101"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Control_Stream_BE" ref="gae2ebee942dae1fe0fb6406583758a101" args="(const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Control_Stream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes the given number of bytes to the CONTROL type endpoint from the given buffer in big endian, sending full packets to the host as needed. The host OUT acknowledgement is not automatically cleared in both failure and success states; the user is responsible for manually clearing the setup OUT to finalize the transfer via the <a class="el" href="a00266.html#ga3e46b62f81211da48ab96d4d1183855f">Endpoint_ClearOUT()</a> macro.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function automatically clears the control transfer's status stage. Do not manually attempt to clear the status stage when using this routine in a control transaction.</dd>
<dd>
This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gab28db1e015f6ccb22987551f0b4b7bb4"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Control_Stream_LE" ref="gab28db1e015f6ccb22987551f0b4b7bb4" args="(const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Control_Stream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes the given number of bytes to the CONTROL type endpoint from the given buffer in little endian, sending full packets to the host as needed. The host OUT acknowledgement is not automatically cleared in both failure and success states; the user is responsible for manually clearing the setup OUT to finalize the transfer via the <a class="el" href="a00266.html#ga3e46b62f81211da48ab96d4d1183855f">Endpoint_ClearOUT()</a> macro.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function automatically clears the control transfer's status stage. Do not manually attempt to clear the status stage when using this routine in a control transaction.</dd>
<dd>
This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga86c80298666003b7288d83f9b0c7789f"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_EStream_BE" ref="ga86c80298666003b7288d83f9b0c7789f" args="(const void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_EStream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="a00265.html#ga9d862432fdc00bae0f98779dd7dbd3eb">Endpoint_Write_Stream_BE()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gabbbc488c3165e1c06ddf3f12ef02e912"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_EStream_LE" ref="gabbbc488c3165e1c06ddf3f12ef02e912" args="(const void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_EStream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="a00265.html#gaa992872885b95569746ea6408b7feca3">Endpoint_Write_Stream_LE()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga95dd14a0bfda413971fb258f415b1944"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_PStream_BE" ref="ga95dd14a0bfda413971fb258f415b1944" args="(const void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_PStream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>FLASH buffer source version of <a class="el" href="a00265.html#ga9d862432fdc00bae0f98779dd7dbd3eb">Endpoint_Write_Stream_BE()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASH data must be located in the first 64KB of FLASH for this function to work correctly.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb0df03d9583e45de27ddf7f380ca571"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_PStream_LE" ref="gacb0df03d9583e45de27ddf7f380ca571" args="(const void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_PStream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>FLASH buffer source version of <a class="el" href="a00265.html#gaa992872885b95569746ea6408b7feca3">Endpoint_Write_Stream_LE()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASH data must be located in the first 64KB of FLASH for this function to work correctly.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9d862432fdc00bae0f98779dd7dbd3eb"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Stream_BE" ref="ga9d862432fdc00bae0f98779dd7dbd3eb" args="(const void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Stream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes the given number of bytes to the endpoint from the given buffer in big endian, sending full packets to the host as needed. The last packet filled is not automatically sent; the user is responsible for manually sending the last written packet to the host via the <a class="el" href="a00266.html#ga7a18211c2800d663a4ef99b5da8f1483">Endpoint_ClearIN()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the endpoint is ready to accept the next packet, allowing for early aborts of stream transfers.</p>
<p>The callback routine should be created according to the information in <a class="el" href="a00260.html">Endpoint and Pipe Stream Callbacks</a>. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter omitted.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa992872885b95569746ea6408b7feca3"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Stream_LE" ref="gaa992872885b95569746ea6408b7feca3" args="(const void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Stream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00260.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes the given number of bytes to the endpoint from the given buffer in little endian, sending full packets to the host as needed. The last packet filled is not automatically sent; the user is responsible for manually sending the last written packet to the host via the <a class="el" href="a00266.html#ga7a18211c2800d663a4ef99b5da8f1483">Endpoint_ClearIN()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the endpoint is ready to accept the next packet, allowing for early aborts of stream transfers.</p>
<p>The callback routine should be created according to the information in <a class="el" href="a00260.html">Endpoint and Pipe Stream Callbacks</a>. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter omitted.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00265.html#ga7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 1 Dec 2009 for LUFA (Formerly MyUSB) Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
