<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LUFA Library - DFU Class Bootloader: BootloaderDFU.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>BootloaderDFU.c File Reference</h1><code>#include &quot;<a class="el" href="a00005.html">BootloaderDFU.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a72dc6ec5d70814bd46cd759b165693c9">INCLUDE_FROM_BOOTLOADER_C</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a840291bc02cba5474a4cb46a9b9566fe">main</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#acb27e569c06a2797c5fd58ed39147448">SetupHardware</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a5aa92c37b3202c4fa9e17b76cf72c9a7">ResetHardware</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#abbebc3cb66ac3945b938ae5b93a71ea8">EVENT_USB_Device_UnhandledControlRequest</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a9f5dda4a64d21500166199780fe00ef3">DiscardFillerBytes</a> (uint8_t NumberOfBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a4df8b3dc9e9038f2544560b6b643967e">ProcessBootloaderCommand</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#afee764fe0d913307b86189d47320c593">LoadStartEndAddresses</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a2a6121c0ac69f5d1ffc61cf8a374342f">ProcessMemProgCommand</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a08bc226c90c59450e1d1697d803a8c25">ProcessMemReadCommand</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#aabcf53cda782ea6a288c5a211e203c7b">ProcessWriteCommand</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a554e0de597375c2c3537d744df715812">ProcessReadCommand</a> (void)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#adb59d1044fe46ad2ddd774ccbc267db1">IsSecure</a> = SECURE_MODE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a997cfdd9124b3e2f863a83f7f7d71c35">RunBootloader</a> = true</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a79938ee4d6c97ef16aef52355eb1f229">WaitForExit</a> = false</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a4736947410e7563e2984f3399e635667">DFU_State</a> = dfuIDLE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a2ba29b60ec9525673c1c476d302a14df">DFU_Status</a> = OK</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00001.html">DFU_Command_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a40f9868e32fbd58a184c112f509ed7f6">SentCommand</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a185062f4b63cb73b9c4b825d6f5951bb">ResponseByte</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00005.html#af456875920c8c853098d9c2f247c32af">AppPtr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a167b0a1aebd4b4dd2185eb415b21e546">AppStartPtr</a> = (<a class="el" href="a00005.html#af456875920c8c853098d9c2f247c32af">AppPtr_t</a>)0x0000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a96d39e5cbd62a6788cb4914cd949f12a">Flash64KBPage</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#ac4661ab0f171fdfe2d86b3b7f6e156a0">StartAddr</a> = 0x0000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a1ef861a8b23d4393f6cb3f7880c1f720">EndAddr</a> = 0x0000</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Main source file for the DFU class bootloader. This file contains the complete bootloader logic. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a72dc6ec5d70814bd46cd759b165693c9"></a><!-- doxytag: member="BootloaderDFU.c::INCLUDE_FROM_BOOTLOADER_C" ref="a72dc6ec5d70814bd46cd759b165693c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INCLUDE_FROM_BOOTLOADER_C</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a9f5dda4a64d21500166199780fe00ef3"></a><!-- doxytag: member="BootloaderDFU.c::DiscardFillerBytes" ref="a9f5dda4a64d21500166199780fe00ef3" args="(uint8_t NumberOfBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void DiscardFillerBytes </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>NumberOfBytes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Routine to discard the specified number of bytes from the control endpoint stream. This is used to discard unused bytes in the stream from the host, including the memory program block suffix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>NumberOfBytes</em>&nbsp;</td><td>Number of bytes to discard from the host from the control endpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbebc3cb66ac3945b938ae5b93a71ea8"></a><!-- doxytag: member="BootloaderDFU.c::EVENT_USB_Device_UnhandledControlRequest" ref="abbebc3cb66ac3945b938ae5b93a71ea8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EVENT_USB_Device_UnhandledControlRequest </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Event handler for the USB_UnhandledControlRequest event. This is used to catch standard and class specific control requests that are not handled internally by the USB library (including the DFU commands, which are all issued via the control endpoint), so that they can be handled appropriately for the application. </p>

</div>
</div>
<a class="anchor" id="afee764fe0d913307b86189d47320c593"></a><!-- doxytag: member="BootloaderDFU.c::LoadStartEndAddresses" ref="afee764fe0d913307b86189d47320c593" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void LoadStartEndAddresses </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Routine to concatenate the given pair of 16-bit memory start and end addresses from the host, and store them in the StartAddr and EndAddr global variables. </p>

</div>
</div>
<a class="anchor" id="a840291bc02cba5474a4cb46a9b9566fe"></a><!-- doxytag: member="BootloaderDFU.c::main" ref="a840291bc02cba5474a4cb46a9b9566fe" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Main program entry point. This routine configures the hardware required by the bootloader, then continuously runs the bootloader processing routine until instructed to soft-exit, or hard-reset via the watchdog to start the loaded application code. </p>

</div>
</div>
<a class="anchor" id="a4df8b3dc9e9038f2544560b6b643967e"></a><!-- doxytag: member="BootloaderDFU.c::ProcessBootloaderCommand" ref="a4df8b3dc9e9038f2544560b6b643967e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ProcessBootloaderCommand </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Routine to process an issued command from the host, via a DFU_DNLOAD request wrapper. This routine ensures that the command is allowed based on the current secure mode flag value, and passes the command off to the appropriate handler function. </p>

</div>
</div>
<a class="anchor" id="a2a6121c0ac69f5d1ffc61cf8a374342f"></a><!-- doxytag: member="BootloaderDFU.c::ProcessMemProgCommand" ref="a2a6121c0ac69f5d1ffc61cf8a374342f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ProcessMemProgCommand </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handler for a Memory Program command issued by the host. This routine handles the preparations needed to write subsequent data from the host into the specified memory. </p>

</div>
</div>
<a class="anchor" id="a08bc226c90c59450e1d1697d803a8c25"></a><!-- doxytag: member="BootloaderDFU.c::ProcessMemReadCommand" ref="a08bc226c90c59450e1d1697d803a8c25" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ProcessMemReadCommand </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handler for a Memory Read command issued by the host. This routine handles the preparations needed to read subsequent data from the specified memory out to the host, as well as implementing the memory blank check command. </p>

</div>
</div>
<a class="anchor" id="a554e0de597375c2c3537d744df715812"></a><!-- doxytag: member="BootloaderDFU.c::ProcessReadCommand" ref="a554e0de597375c2c3537d744df715812" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ProcessReadCommand </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handler for a Data Read command issued by the host. This routine handles bootloader information retrieval commands such as device signature and bootloader version retrieval. </p>

</div>
</div>
<a class="anchor" id="aabcf53cda782ea6a288c5a211e203c7b"></a><!-- doxytag: member="BootloaderDFU.c::ProcessWriteCommand" ref="aabcf53cda782ea6a288c5a211e203c7b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ProcessWriteCommand </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handler for a Data Write command issued by the host. This routine handles non-programming commands such as bootloader exit (both via software jumps and hardware watchdog resets) and flash memory erasure. </p>

</div>
</div>
<a class="anchor" id="a5aa92c37b3202c4fa9e17b76cf72c9a7"></a><!-- doxytag: member="BootloaderDFU.c::ResetHardware" ref="a5aa92c37b3202c4fa9e17b76cf72c9a7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ResetHardware </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets all configured hardware required for the bootloader back to their original states. </p>

</div>
</div>
<a class="anchor" id="acb27e569c06a2797c5fd58ed39147448"></a><!-- doxytag: member="BootloaderDFU.c::SetupHardware" ref="acb27e569c06a2797c5fd58ed39147448" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetupHardware </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures all hardware required for the bootloader. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a167b0a1aebd4b4dd2185eb415b21e546"></a><!-- doxytag: member="BootloaderDFU.c::AppStartPtr" ref="a167b0a1aebd4b4dd2185eb415b21e546" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00005.html#af456875920c8c853098d9c2f247c32af">AppPtr_t</a> <a class="el" href="a00004.html#a167b0a1aebd4b4dd2185eb415b21e546">AppStartPtr</a> = (<a class="el" href="a00005.html#af456875920c8c853098d9c2f247c32af">AppPtr_t</a>)0x0000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the start of the user application. By default this is 0x0000 (the reset vector), however the host may specify an alternate address when issuing the application soft-start command. </p>

</div>
</div>
<a class="anchor" id="a4736947410e7563e2984f3399e635667"></a><!-- doxytag: member="BootloaderDFU.c::DFU_State" ref="a4736947410e7563e2984f3399e635667" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="a00004.html#a4736947410e7563e2984f3399e635667">DFU_State</a> = dfuIDLE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Current DFU state machine state, one of the values in the DFU_State_t enum. </p>

</div>
</div>
<a class="anchor" id="a2ba29b60ec9525673c1c476d302a14df"></a><!-- doxytag: member="BootloaderDFU.c::DFU_Status" ref="a2ba29b60ec9525673c1c476d302a14df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="a00004.html#a2ba29b60ec9525673c1c476d302a14df">DFU_Status</a> = OK</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Status code of the last executed DFU command. This is set to one of the values in the DFU_Status_t enum after each operation, and returned to the host when a Get Status DFU request is issued. </p>

</div>
</div>
<a class="anchor" id="a1ef861a8b23d4393f6cb3f7880c1f720"></a><!-- doxytag: member="BootloaderDFU.c::EndAddr" ref="a1ef861a8b23d4393f6cb3f7880c1f720" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="a00004.html#a1ef861a8b23d4393f6cb3f7880c1f720">EndAddr</a> = 0x0000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Memory end address, indicating the end address to read to/write from in the memory being addressed (either FLASH of EEPROM depending on the issued command from the host). </p>

</div>
</div>
<a class="anchor" id="a96d39e5cbd62a6788cb4914cd949f12a"></a><!-- doxytag: member="BootloaderDFU.c::Flash64KBPage" ref="a96d39e5cbd62a6788cb4914cd949f12a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="a00004.html#a96d39e5cbd62a6788cb4914cd949f12a">Flash64KBPage</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>64-bit flash page number. This is concatenated with the current 16-bit address on USB AVRs containing more than 64KB of flash memory. </p>

</div>
</div>
<a class="anchor" id="adb59d1044fe46ad2ddd774ccbc267db1"></a><!-- doxytag: member="BootloaderDFU.c::IsSecure" ref="adb59d1044fe46ad2ddd774ccbc267db1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00004.html#adb59d1044fe46ad2ddd774ccbc267db1">IsSecure</a> = SECURE_MODE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flag to indicate if the bootloader is currently running in secure mode, disallowing memory operations other than erase. This is initially set to the value set by SECURE_MODE, and cleared by the bootloader once a memory erase has completed. </p>

</div>
</div>
<a class="anchor" id="a185062f4b63cb73b9c4b825d6f5951bb"></a><!-- doxytag: member="BootloaderDFU.c::ResponseByte" ref="a185062f4b63cb73b9c4b825d6f5951bb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="a00004.html#a185062f4b63cb73b9c4b825d6f5951bb">ResponseByte</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Response to the last issued Read Data DFU command. Unlike other DFU commands, the read command requires a single byte response from the bootloader containing the read data when the next DFU_UPLOAD command is issued by the host. </p>

</div>
</div>
<a class="anchor" id="a997cfdd9124b3e2f863a83f7f7d71c35"></a><!-- doxytag: member="BootloaderDFU.c::RunBootloader" ref="a997cfdd9124b3e2f863a83f7f7d71c35" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00004.html#a997cfdd9124b3e2f863a83f7f7d71c35">RunBootloader</a> = true</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flag to indicate if the bootloader should be running, or should exit and allow the application code to run via a soft reset. When cleared, the bootloader will abort, the USB interface will shut down and the application jumped to via an indirect jump to location 0x0000 (or other location specified by the host). </p>

</div>
</div>
<a class="anchor" id="a40f9868e32fbd58a184c112f509ed7f6"></a><!-- doxytag: member="BootloaderDFU.c::SentCommand" ref="a40f9868e32fbd58a184c112f509ed7f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00001.html">DFU_Command_t</a> <a class="el" href="a00004.html#a40f9868e32fbd58a184c112f509ed7f6">SentCommand</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Data containing the DFU command sent from the host. </p>

</div>
</div>
<a class="anchor" id="ac4661ab0f171fdfe2d86b3b7f6e156a0"></a><!-- doxytag: member="BootloaderDFU.c::StartAddr" ref="ac4661ab0f171fdfe2d86b3b7f6e156a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="a00004.html#ac4661ab0f171fdfe2d86b3b7f6e156a0">StartAddr</a> = 0x0000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Memory start address, indicating the current address in the memory being addressed (either FLASH or EEPROM depending on the issued command from the host). </p>

</div>
</div>
<a class="anchor" id="a79938ee4d6c97ef16aef52355eb1f229"></a><!-- doxytag: member="BootloaderDFU.c::WaitForExit" ref="a79938ee4d6c97ef16aef52355eb1f229" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00004.html#a79938ee4d6c97ef16aef52355eb1f229">WaitForExit</a> = false</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flag to indicate if the bootloader is waiting to exit. When the host requests the bootloader to exit and jump to the application address it specifies, it sends two sequential commands which must be properly acknowledged. Upon reception of the first the RunBootloader flag is cleared and the WaitForExit flag is set, causing the bootloader to wait for the final exit command before shutting down. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 1 Dec 2009 for LUFA Library - DFU Class Bootloader by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
