<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LUFA Library - RNDIS Ethernet Demo: Lib/TCP.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_d77e6cf0c165ab3a75bef9cd0cd2cae8.html">Lib</a>
  </div>
</div>
<div class="contents">
<h1>TCP.c File Reference</h1><code>#include &quot;<a class="el" href="a00030.html">TCP.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html#a7a88f0069d0481916e2a8bafd90a6af8">INCLUDE_FROM_TCP_C</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html#aee15c5b8206010f832d69a6090a1c9c6">TCP_TCPTask</a> (USB_ClassInfo_RNDIS_Device_t *RNDISInterfaceInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html#a3a02a29f93af673139608232298ef119">TCP_Init</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html#a6ff3b7111e8b2a222d0d012d21e6f816">TCP_SetPortState</a> (uint16_t Port, uint8_t State, void(*Handler)(<a class="el" href="a00009.html">TCP_ConnectionState_t</a> *, <a class="el" href="a00007.html">TCP_ConnectionBuffer_t</a> *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html#a19ec402ee56a161c6800aabd3021c534">TCP_GetPortState</a> (uint16_t Port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html#a86e31a4ceebb404530f69ed0c8043860">TCP_SetConnectionState</a> (uint16_t Port, <a class="el" href="a00005.html">IP_Address_t</a> RemoteAddress, uint16_t RemotePort, uint8_t State)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html#a8220af0f8567fbc3271e42eee3bd920f">TCP_GetConnectionState</a> (uint16_t Port, <a class="el" href="a00005.html">IP_Address_t</a> RemoteAddress, uint16_t RemotePort)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00008.html">TCP_ConnectionInfo_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html#a783acbf7e1aec15d2fb49f06dd5a0448">TCP_GetConnectionInfo</a> (uint16_t Port, <a class="el" href="a00005.html">IP_Address_t</a> RemoteAddress, uint16_t RemotePort)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html#aa2bf6261c8743fd64cb4e8f3f59498ee">TCP_ProcessTCPPacket</a> (void *IPHeaderInStart, void *TCPHeaderInStart, void *TCPHeaderOutStart)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html#a83628fae62c44286abeb78fada2b91bb">TCP_Checksum16</a> (void *TCPHeaderOutStart, <a class="el" href="a00005.html">IP_Address_t</a> SourceAddress, <a class="el" href="a00005.html">IP_Address_t</a> DestinationAddress, uint16_t TCPOutSize)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00011.html">TCP_PortState_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html#af2e38fb19ac4d5ce52d9b52f5f227f8e">PortStateTable</a> [MAX_OPEN_TCP_PORTS]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00009.html">TCP_ConnectionState_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html#a651f91ede4e43961a77e264996aea775">ConnectionStateTable</a> [MAX_TCP_CONNECTIONS]</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Transmission Control Protocol (TCP) packet handling routines. This protocol handles the reliable in-order transmission and reception of packets to and from devices on a network, to "ports" on the device. It is used in situations where data delivery must be reliable and correct, e.g. HTTP, TELNET and most other non-streaming protocols. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a7a88f0069d0481916e2a8bafd90a6af8"></a><!-- doxytag: member="TCP.c::INCLUDE_FROM_TCP_C" ref="a7a88f0069d0481916e2a8bafd90a6af8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INCLUDE_FROM_TCP_C</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a83628fae62c44286abeb78fada2b91bb"></a><!-- doxytag: member="TCP.c::TCP_Checksum16" ref="a83628fae62c44286abeb78fada2b91bb" args="(void *TCPHeaderOutStart, IP_Address_t SourceAddress, IP_Address_t DestinationAddress, uint16_t TCPOutSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t TCP_Checksum16 </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>TCPHeaderOutStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00005.html">IP_Address_t</a>&nbsp;</td>
          <td class="paramname"> <em>SourceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00005.html">IP_Address_t</a>&nbsp;</td>
          <td class="paramname"> <em>DestinationAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>TCPOutSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the appropriate TCP checksum, consisting of the addition of the one's compliment of each word, complimented.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>TCPHeaderOutStart</em>&nbsp;</td><td>Pointer to the start of the packet's outgoing TCP header </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>SourceAddress</em>&nbsp;</td><td>Source protocol IP address of the outgoing IP header </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>DestinationAddress</em>&nbsp;</td><td>Destination protocol IP address of the outgoing IP header </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>TCPOutSize</em>&nbsp;</td><td>Size in bytes of the TCP data header and payload</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 16-bit TCP checksum value </dd></dl>

</div>
</div>
<a class="anchor" id="a783acbf7e1aec15d2fb49f06dd5a0448"></a><!-- doxytag: member="TCP.c::TCP_GetConnectionInfo" ref="a783acbf7e1aec15d2fb49f06dd5a0448" args="(uint16_t Port, IP_Address_t RemoteAddress, uint16_t RemotePort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00008.html">TCP_ConnectionInfo_t</a>* TCP_GetConnectionInfo </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00005.html">IP_Address_t</a>&nbsp;</td>
          <td class="paramname"> <em>RemoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>RemotePort</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the connection info structure of a given connection to a host.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Port</em>&nbsp;</td><td>TCP port on the device in the connection, specified in big endian </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>RemoteAddress</em>&nbsp;</td><td>Remote protocol IP address of the connected host </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>RemotePort</em>&nbsp;</td><td>Remote TCP port of the connected host, specified in big endian</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ConnectionInfo structure of the connection if found, NULL otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a8220af0f8567fbc3271e42eee3bd920f"></a><!-- doxytag: member="TCP.c::TCP_GetConnectionState" ref="a8220af0f8567fbc3271e42eee3bd920f" args="(uint16_t Port, IP_Address_t RemoteAddress, uint16_t RemotePort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t TCP_GetConnectionState </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00005.html">IP_Address_t</a>&nbsp;</td>
          <td class="paramname"> <em>RemoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>RemotePort</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the current state of a given TCP connection to a host.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Port</em>&nbsp;</td><td>TCP port on the device in the connection, specified in big endian </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>RemoteAddress</em>&nbsp;</td><td>Remote protocol IP address of the connected host </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>RemotePort</em>&nbsp;</td><td>Remote TCP port of the connected host, specified in big endian</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the TCP_ConnectionStates_t enum </dd></dl>

</div>
</div>
<a class="anchor" id="a19ec402ee56a161c6800aabd3021c534"></a><!-- doxytag: member="TCP.c::TCP_GetPortState" ref="a19ec402ee56a161c6800aabd3021c534" args="(uint16_t Port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t TCP_GetPortState </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Port</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the current state of a given TCP port, specified in big endian.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Port</em>&nbsp;</td><td>TCP port whose state is to be retrieved, given in big-endian</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the TCP_PortStates_t enum </dd></dl>

</div>
</div>
<a class="anchor" id="a3a02a29f93af673139608232298ef119"></a><!-- doxytag: member="TCP.c::TCP_Init" ref="a3a02a29f93af673139608232298ef119" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCP_Init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the TCP protocol handler, clearing the port and connection state tables. This must be called before TCP packets are processed. </p>

</div>
</div>
<a class="anchor" id="aa2bf6261c8743fd64cb4e8f3f59498ee"></a><!-- doxytag: member="TCP.c::TCP_ProcessTCPPacket" ref="aa2bf6261c8743fd64cb4e8f3f59498ee" args="(void *IPHeaderInStart, void *TCPHeaderInStart, void *TCPHeaderOutStart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t TCP_ProcessTCPPacket </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>IPHeaderInStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>TCPHeaderInStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>TCPHeaderOutStart</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Processes a TCP packet inside an Ethernet frame, and writes the appropriate response to the output Ethernet frame if one is created by a application handler.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IPHeaderInStart</em>&nbsp;</td><td>Pointer to the start of the incoming packet's IP header </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>TCPHeaderInStart</em>&nbsp;</td><td>Pointer to the start of the incoming packet's TCP header </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>TCPHeaderOutStart</em>&nbsp;</td><td>Pointer to the start of the outgoing packet's TCP header</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes written to the out Ethernet frame if any, NO_RESPONSE if no response was generated, NO_PROCESS if the packet processing was deferred until the next Ethernet packet handler iteration </dd></dl>

</div>
</div>
<a class="anchor" id="a86e31a4ceebb404530f69ed0c8043860"></a><!-- doxytag: member="TCP.c::TCP_SetConnectionState" ref="a86e31a4ceebb404530f69ed0c8043860" args="(uint16_t Port, IP_Address_t RemoteAddress, uint16_t RemotePort, uint8_t State)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TCP_SetConnectionState </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00005.html">IP_Address_t</a>&nbsp;</td>
          <td class="paramname"> <em>RemoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>RemotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>State</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the connection state of the given port, remote address and remote port to the given TCP connection state. If the connection exists in the connection state table it is updated, otherwise it is created if possible.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Port</em>&nbsp;</td><td>TCP port of the connection on the device, specified in big endian </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>RemoteAddress</em>&nbsp;</td><td>Remote protocol IP address of the connected device </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>RemotePort</em>&nbsp;</td><td>TCP port of the remote device in the connection, specified in big endian </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>State</em>&nbsp;</td><td>TCP connection state, a value from the TCP_ConnectionStates_t enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if the connection was updated or created, false otherwise (no more space in the connection state table) </dd></dl>

</div>
</div>
<a class="anchor" id="a6ff3b7111e8b2a222d0d012d21e6f816"></a><!-- doxytag: member="TCP.c::TCP_SetPortState" ref="a6ff3b7111e8b2a222d0d012d21e6f816" args="(uint16_t Port, uint8_t State, void(*Handler)(TCP_ConnectionState_t *, TCP_ConnectionBuffer_t *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TCP_SetPortState </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>State</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="a00009.html">TCP_ConnectionState_t</a> *, <a class="el" href="a00007.html">TCP_ConnectionBuffer_t</a> *)&nbsp;</td>
          <td class="paramname"> <em>Handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the state and callback handler of the given port, specified in big endian to the given state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Port</em>&nbsp;</td><td>Port whose state and callback function to set, specified in big endian </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>State</em>&nbsp;</td><td>New state of the port, a value from the TCP_PortStates_t enum </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Handler</em>&nbsp;</td><td>Application callback handler for the port</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if the port state was set, false otherwise (no more space in the port state table) </dd></dl>

</div>
</div>
<a class="anchor" id="aee15c5b8206010f832d69a6090a1c9c6"></a><!-- doxytag: member="TCP.c::TCP_TCPTask" ref="aee15c5b8206010f832d69a6090a1c9c6" args="(USB_ClassInfo_RNDIS_Device_t *RNDISInterfaceInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCP_TCPTask </td>
          <td>(</td>
          <td class="paramtype">USB_ClassInfo_RNDIS_Device_t *&nbsp;</td>
          <td class="paramname"> <em>RNDISInterfaceInfo</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT buffer for later transmission. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a651f91ede4e43961a77e264996aea775"></a><!-- doxytag: member="TCP.c::ConnectionStateTable" ref="a651f91ede4e43961a77e264996aea775" args="[MAX_TCP_CONNECTIONS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00009.html">TCP_ConnectionState_t</a> <a class="el" href="a00029.html#a651f91ede4e43961a77e264996aea775">ConnectionStateTable</a>[MAX_TCP_CONNECTIONS]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connection state table array. This contains the current status of TCP connections in the device. To save on space, only active (non-closed) connections are stored - closed connections may be overwritten at any time, and the system will assume any connections not present in the array are closed. </p>

</div>
</div>
<a class="anchor" id="af2e38fb19ac4d5ce52d9b52f5f227f8e"></a><!-- doxytag: member="TCP.c::PortStateTable" ref="af2e38fb19ac4d5ce52d9b52f5f227f8e" args="[MAX_OPEN_TCP_PORTS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00011.html">TCP_PortState_t</a> <a class="el" href="a00030.html#af2e38fb19ac4d5ce52d9b52f5f227f8e">PortStateTable</a>[MAX_OPEN_TCP_PORTS]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Port state table array. This contains the current status of TCP ports in the device. To save on space, only open ports are stored - closed ports may be overwritten at any time, and the system will assume any ports not present in the array are closed. This allows for MAX_OPEN_TCP_PORTS to be less than the number of ports used by the application if desired. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 1 Dec 2009 for LUFA Library - RNDIS Ethernet Demo by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
